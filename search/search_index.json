{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Designing a cohesive media experience for Android can be a lot of work. Telephoto aims to make that easier by offering some building blocks:</p>"},{"location":"#zoomable-image","title":"Zoomable Image","text":"<p>Drop-in replacement for <code>Image()</code> composables featuring support for pan &amp; zoom gestures and automatic sub\u2011sampling of large images that'd otherwise not fit into memory.</p>"},{"location":"#modifierzoomable","title":"Modifier.zoomable()","text":"<p><code>ZoomableImage</code>'s gesture detector, packaged as a standalone <code>Modifier</code> that can be used with non-image composables.</p>"},{"location":"zoomable/","title":"Modifier.zoomable()","text":"<p>A <code>Modifier</code> for handling pan &amp; zoom gestures, designed to be shared across all your media composables so that your users can use the same familiar gestures throughout your app. It offers,</p> <ul> <li>Pinch to zoom and flings</li> <li>Double tap to zoom</li> <li>Single finger zoom (double tap and hold)</li> <li>Haptic feedback for over/under zoom</li> <li>Compatibility with nested scrolling</li> <li>Click listeners</li> </ul> <pre><code>implementation(\"me.saket.telephoto:zoomable:1.0.0-SNAPSHOT\")\n</code></pre> <pre><code>Box(\nModifier\n.size(200.dp)\n.zoomable(rememberZoomableState())\n.background(\nbrush = Brush.linearGradient(listOf(Color.Cyan, Color.Blue)),\nshape = RoundedCornerShape(4.dp)\n)\n)\n</code></pre> <p>While <code>Modifier.zoomable()</code> was primarily written with images &amp; videos in mind, it can be used for anything such as text, canvas drawings, etc.</p>"},{"location":"zoomable/#click-listeners","title":"Click listeners","text":"<p>For detecting double taps, <code>Modifier.zoomable()</code> consumes all tap gestures making it incompatible with <code>Modifier.clickable()</code> and <code>Modifier.combinedClickable()</code>. As an alternative, its <code>onClick</code> and <code>onLongClick</code> parameters can be used.</p> <pre><code>Modifier.zoomable(\nstate = rememberZoomableState(),\nonClick = { \u2026 },\nonLongClick = { \u2026 },\n)\n</code></pre>"},{"location":"zoomable/#preventing-over-zoom","title":"Preventing over-zoom","text":"<p>For preventing your content from over-zooming or over-panning, <code>Modifier.zoomable()</code> will use your content's layout size by default. This is good enough for composables that fill every pixel of their drawing space.</p> <p>For richer content such as an <code>Image()</code> whose visual size may not always match its layout size, <code>Modifier.zoomable()</code> will need your assistance.</p> <pre><code>val state = rememberZoomableState()\nval painter = resourcePainter(R.drawable.example)\nLaunchedEffect(painter) {\nstate.setContentLocation(\nZoomableContentLocation.scaledInsideAndCenterAligned(painter.intrinsicSize)\n)\n}\nImage(\nmodifier = Modifier\n.fillMaxSize()\n.zoomable(state),\npainter = painter,\ncontentDescription = \u2026,\ncontentScale = ContentScale.Inside,\nalignment = Alignment.Center,\n)\n</code></pre>"},{"location":"zoomable/#applying-gesture-transformations","title":"Applying gesture transformations","text":"<p>When pan &amp; zoom gestures are received, <code>Modifier.zoomable()</code> automatically applies their resulting <code>scale</code> and <code>translation</code> onto your content using <code>Modifier.graphicsLayer()</code>. </p> <p>This can be disabled if your content prefers applying the transformations in a bespoke manner.</p> <pre><code>val state = rememberZoomableState(\nautoApplyTransformations = false\n)\nText(\nmodifier = Modifier\n.fillMaxSize()\n.zoomable(state),\ntext = \"Nicolas Cage\",\nstyle = state.contentTransformation.let {\nval weightMultiplier = if (it.isUnspecified) 1f else it.scale.scaleX\nTextStyle(\nfontSize = 36.sp,\nfontWeight = FontWeight(400 * weightMultiplier),\n)\n}\n)\n</code></pre>"},{"location":"zoomable/recipes/","title":"Recipes","text":""},{"location":"zoomable/recipes/#observing-pan-zoom","title":"Observing pan &amp; zoom","text":"<pre><code>val state = rememberZoomableState()\nBox(\nModifier.zoomable(state)\n)\nLaunchedEffect(state.contentTransformation) {\nprintln(\"Pan = ${state.contentTransformation.offset}\")\nprintln(\"Zoom = ${state.contentTransformation.scale}\")\nprintln(\"Zoom percent = ${state.zoomFraction * 100}%\")\n}\n// Example use case: Hide system bars when image is zoomed in.\nval systemUiController = rememberSystemUiController()\nsystemUiController.isSystemBarsVisible = state.zoomFraction == 0f\n</code></pre>"},{"location":"zoomable/recipes/#resetting-zoom","title":"Resetting zoom","text":"<p><code>Modifier.zoomable()</code> will automatically retain its pan &amp; zoom across state restorations. You may want to prevent this in lazy layouts such as a <code>Pager()</code>, where each page is restored every time it becomes visible. </p> <pre><code>val pagerState = rememberPagerState()\nHorizontalPager(\nstate = pagerState,\npageCount = 3,\n) { pageNum -&gt;\nval zoomableState = rememberZoomableState()\nZoomableContent(\nstate = zoomableState\n)\nif (pagerState.settledPage != pageNum) {\n// Page is now off-screen. Prevent restoration of \n// current zoom when this page becomes visible again.\nLaunchedEffect(Unit) {\nzoomableState.resetZoomImmediately()\n}\n}\n}\n</code></pre> <p>Warning</p> <p>A bug in <code>Pager()</code> previously caused <code>settledPage</code> to reset to <code>0</code> upon state restoration. This issue has been resolved in version <code>1.5.0-alpha02</code>.</p>"},{"location":"zoomableimage/","title":"Zoomable Image","text":"<p>A drop-in replacement for async <code>Image()</code> composables featuring support for pan &amp; zoom gestures and automatic sub-sampling of large images. This ensures that images maintain their intricate details even when fully zoomed in, without causing any <code>OutOfMemory</code> exceptions.</p> CoilGlide <pre><code>implementation(\"me.saket.telephoto:zoomable-image-coil:1.0.0-SNAPSHOT\")\n</code></pre> <pre><code>implementation(\"me.saket.telephoto:zoomable-image-glide:1.0.0-SNAPSHOT\")\n</code></pre> CoilGlide <pre><code>- AsyncImage(\n+ ZoomableAsyncImage(\n   model = \"https://example.com/image.jpg\",\n    contentDescription = \u2026\n  )\n</code></pre> <pre><code>- GlideImage(\n+ ZoomableGlideImage(\n   model = \"https://example.com/image.jpg\",\n    contentDescription = \u2026\n  )\n</code></pre>"},{"location":"zoomableimage/#image-requests","title":"Image requests","text":"<p>For complex scenarios, the <code>model</code> parameter can take full image requests. </p> CoilGlide <pre><code>ZoomableAsyncImage(\nmodel = ImageRequest.Builder(LocalContext.current)\n.data(\"https://example.com/image.jpg\")\n.listener(\nonSuccess = { \u2026 },\nonError = { \u2026 }\n)\n.crossfade(1_000)\n.memoryCachePolicy(CachePolicy.DISABLED)\n.build(),\nimageLoader = LocalContext.current.imageLoader, // Optional.\ncontentDescription = \u2026\n)\n</code></pre> <pre><code>ZoomableGlideImage(\nmodel = Glide.with(LocalContext.current)\n.load(\"https://example.com/image.jpg\")\n.addListener(object : RequestListener&lt;Drawable&gt; {\noverride fun onResourceReady(\u2026): Boolean = TODO()\noverride fun onLoadFailed(\u2026): Boolean = TODO()\n})\n.transition(withCrossFade(1_000))\n.skipMemoryCache(true)\n.disallowHardwareConfig()\n.timeout(30_000),\ncontentDescription = \u2026\n)\n</code></pre>"},{"location":"zoomableimage/#placeholders","title":"Placeholders","text":"<p>If your images are available in multiple resolutions, <code>telephoto</code> highly recommends using their lower resolutions as placeholders while their full quality equivalents are loaded in the background.</p> <p>When combined with a cross-fade transition, <code>ZoomableImage</code> will smoothly swap out placeholders when their full quality versions are ready to be displayed.</p> CoilGlide <p><pre><code>ZoomableAsyncImage(\nmodifier = Modifier.fillMaxSize(),\nmodel = ImageRequest.Builder(LocalContext.current)\n.data(\"https://example.com/image.jpg\")\n.placeholderMemoryCacheKey(\u2026)\n.crossfade(1000)\n.build(),\ncontentDescription = \u2026\n)\n</code></pre> More details about <code>placeholderMemoryCacheKey()</code> can be found on Coil's website.</p> <p><pre><code>ZoomableGlideImage(\nmodifier = Modifier.fillMaxSize(),\nmodel = Glide.with(LocalContext.current)\n.load(\"https://example.com/image.jpg\")\n.thumbnail(\u2026)   // or placeholder()\n.transition(withCrossFade(1000)),\ncontentDescription = \u2026\n)\n</code></pre> More details about <code>thumbnail()</code> can be found on Glide's website.</p>"},{"location":"zoomableimage/#click-listeners","title":"Click listeners","text":"<p>For detecting double taps, <code>Modifier.zoomable()</code> consumes all tap gestures making it incompatible with <code>Modifier.clickable()</code> and <code>Modifier.combinedClickable()</code>. As an alternative, its <code>onClick</code> and <code>onLongClick</code> parameters can be used.</p> CoilGlide <pre><code>ZoomableAsyncImage(\nmodifier = Modifier.clickable { error(\"This will not work\") },\nmodel = \"https://example.com/image.jpg\",\nonClick = { \u2026 },\nonLongClick = { \u2026 },\n)\n</code></pre> <pre><code>ZoomableGlideImage(\nmodifier = Modifier.clickable { error(\"This will not work\") },\nmodel = \"https://example.com/image.jpg\",\nonClick = { \u2026 },\nonLongClick = { \u2026 },\n)\n</code></pre>"},{"location":"zoomableimage/#sharing-hoisted-state","title":"Sharing hoisted state","text":"<p>For handling zoom gestures, <code>Zoomablemage</code> uses <code>Modifier.zoomable()</code> underneath. If your app displays different kinds of media, it is recommended to hoist the <code>ZoomableState</code> outside so that it can be shared with all zoomable composables:</p> CoilGlide <pre><code>val zoomableState = rememberZoomableState()\nwhen (media) {\nis Image -&gt; {\nZoomableAsyncImage(\nmodel = media.imageUrl,\nstate = rememberZoomableImageState(zoomableState),\n)\n}\nis Video -&gt; {\nZoomableVideoPlayer(\nmodel = media.videoUrl,\nstate = rememberZoomableExoState(zoomableState),\n)\n}\n}\n</code></pre> <pre><code>val zoomableState = rememberZoomableState()\nwhen (media) {\nis Image -&gt; {\nZoomableGlideImage(\nmodel = media.imageUrl,\nstate = rememberZoomableImageState(zoomableState),\n)\n}\nis Video -&gt; {\nZoomableVideoPlayer(\nmodel = media.videoUrl,\nstate = rememberZoomableExoState(zoomableState),\n)\n}\n}\n</code></pre>"},{"location":"zoomableimage/content-alignment/","title":"Content alignment","text":"<p>Work in progress.</p>"},{"location":"zoomableimage/custom-image-loaders/","title":"Custom image loaders","text":"<p>In its essence, <code>ZoomableImage</code> is simply an abstraction over an image loading library. If your preferred library isn't supported by <code>telephoto</code> out of the box, you can create your own by extending <code>ZoomableImageSource</code>.</p> <pre><code>@Composable\nfun ZoomablePicassoImage(\nmodel: Any?,\ncontentDescription: String?,\n) {\nZoomableImage(\nimage = ZoomableImageSource.picasso(model),\ncontentDescription = contentDescription,\n)\n}\n@Composable\nprivate fun ZoomableImageSource.Companion.picasso(\nmodel: Any?,\npicasso: Picasso = Picasso\n.Builder(LocalContext.current)\n.build(),\n): ZoomableImageSource {\nreturn remember(model, picasso) {\nTODO(\"See ZoomableImageSource.coil() or glide() for an example.\")\n}\n}\n</code></pre> <p><code>ZoomableImageSource.picasso()</code> will be responsible for loading an image and deciding whether it can be shown as-is or should be shown in a sub-sampling image viewer to avoid OOMs. Here are two examples:</p> <ul> <li>CoilImageSource</li> <li>GlideImageSource</li> </ul>"},{"location":"zoomableimage/recipes/","title":"Recipes","text":""},{"location":"zoomableimage/recipes/#modifierzoomable","title":"Modifier.zoomable()","text":"<ul> <li>Observing pan &amp; zoom</li> <li>Resetting zoom</li> </ul>"},{"location":"zoomableimage/recipes/#grabbing-downloaded-images","title":"Grabbing downloaded images","text":"<p>Low resolution drawables can be accessed by using request listeners. These images are down-sampled by your image loading library to fit in memory and are suitable for simple use-cases such as color extraction.</p> CoilGlide <pre><code>ZoomableAsyncImage(\nmodel = ImageRequest.Builder(LocalContext.current)\n.data(\"https://example.com/image.jpg\")\n.listener(onSuccess = { _, result -&gt;\n// TODO: do something with result.drawable.\n})\n.build(),\ncontentDescription = \u2026\n)\n</code></pre> <pre><code>ZoomableGlideImage(\nmodel = Glide.with(LocalContext.current)\n.load(\"https://example.com/image.jpg\")\n.addListener(object : RequestListener&lt;Drawable&gt; {\noverride fun onResourceReady(resource: Drawable, \u2026): Boolean {\n// TODO: do something with resource.\n}\n}),\ncontentDescription = \u2026\n)\n</code></pre> <p>Full resolutions must be obtained as files because <code>ZoomableImage</code> streams them directly from disk. The easiest way to do this is to load them again from cache.</p> CoilGlide <p><pre><code>val state = rememberZoomableImageState()\nZoomableAsyncImage(\nmodel = imageUrl,\nstate = state,\ncontentDescription = \u2026,\n)\nif (state.isImageDisplayed) {\nButton(onClick = { downloadImage(context, imageUrl) }) {\nText(\"Download image\")\n}\n}\n</code></pre> <pre><code>suspend fun downloadImage(context: Context, imageUrl: HttpUrl) {\nval result = context.imageLoader.execute(\nImageRequest.Builder(context)\n.data(imageUrl)\n.build()\n)\nif (result is SuccessResult) {\nval cacheKey = result.diskCacheKey ?: error(\"image wasn't saved to disk\")\nval diskCache = context.imageLoader.diskCache!!\n// TODO: copy to Downloads directory.\nval imageFile: Path = diskCache[cacheKey]!!.data\n}\n}\n</code></pre></p> <p><pre><code>val state = rememberZoomableImageState()\nZoomableGlideImage(\nmodel = imageUrl,\nstate = state,\ncontentDescription = \u2026,\n)\nif (state.isImageDisplayed) {\nButton(onClick = { downloadImage(context, imageUrl) }) {\nText(\"Download image\")\n}\n}\n</code></pre> <pre><code>fun downloadImage(context: Context, imageUrl: Uri) {\nGlide.with(context)\n.download(imageUrl)\n.into(object : CustomTarget&lt;File&gt;() {\noverride fun onResourceReady(resource: File, \u2026) {\n// TODO: copy file to Downloads directory.\n}\noverride fun onLoadCleared(placeholder: Drawable?) = Unit\n)\n}\n</code></pre></p>"},{"location":"zoomableimage/sub-sampling/","title":"Sub-sampling","text":"<p>For displaying large images that can't fit into memory, <code>ZoomableImage</code> automatically divides them into tiles so that they can be loaded lazily.</p> <p>If <code>ZoomableImage</code> can't be used or if sub-sampling of images is always desired, you could potentially use <code>SubSamplingImage()</code> directly.</p> <pre><code>implementation(\"me.saket.telephoto:sub-sampling-image:1.0.0-SNAPSHOT\")\n</code></pre> <pre><code>val zoomableState = rememberZoomableState()\nval imageState = rememberSubSamplingImageState(\nzoomableState = zoomableState,\nimageSource = ImageSource.asset(\"fox.jpg\")\n)\nSubSamplingImage(\nmodifier = Modifier\n.fillMaxSize()\n.zoomable(zoomableState),\nstate = imageState,\ncontentDescription = \u2026,\n)\n</code></pre> <p><code>SubSamplingImage()</code> is an adaptation of the excellent subsampling-scale-image-view by Dave Morrissey.</p>"}]}