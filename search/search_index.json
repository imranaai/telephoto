{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Designing a cohesive media experience for Android can be a lot of work. Telephoto aims to make that easier by offering some building blocks:</p>"},{"location":"#modifierzoomable","title":"<code>Modifier.zoomable()</code>","text":"<p>Handle pan &amp; zoom gestures in a consistent manner across your app.</p>"},{"location":"#zoomable-image","title":"Zoomable Image","text":"<p>Drop-in replacement for <code>Image()</code> composables with support for zoom gestures and sub\u2011sampling of large bitmaps that'd otherwise not fit in memory.</p>"},{"location":"zoomable/","title":"<code>Modifier.zoomable()</code>","text":"<p>A modifier for handling pan &amp; zoom gestures, designed to be shared across all your media composables so that your users can use the same familiar gestures throughout your app. It supports,</p> <ul> <li>Pinch to zoom and flings</li> <li>Double tap to zoom</li> <li>Single finger zoom (double tap and hold)</li> <li>Compatibility with nested scrolling</li> <li>Click listeners</li> <li>Haptic feedback for over/under zoom</li> </ul> <pre><code>implementation(\"me.saket.telephoto:zoomable:1.0.0-SNAPSHOT\")\n</code></pre> <pre><code>Box(\nModifier\n.size(200.dp)\n.zoomable(rememberZoomableState())\n.background(\nbrush = Brush.linearGradient(listOf(Color.Cyan, Color.Blue)),\nshape = RoundedCornerShape(4.dp)\n)\n)\n</code></pre> <p>While <code>Modifier.zoomable()</code> was primarily written with images &amp; videos in mind, it can be used for anything such as text, canvas drawings, etc.</p>"},{"location":"zoomable/#click-listeners","title":"Click listeners","text":"<p>For detecting double taps, <code>Modifier.zoomable()</code> is sadly forced to consume all tap gestures making it incompatible with <code>Modifier.clickable()</code> and <code>Modifier.combinedClickable()</code>. As an alternative, its <code>onClick</code> and <code>onLongClick</code> parameters can be used.</p> <pre><code>Modifier.zoomable(\nstate = rememberZoomableState(),\nonClick = { \u2026 },\nonLongClick = { \u2026 },\n)\n</code></pre>"},{"location":"zoomable/#preventing-over-zoom","title":"Preventing over-zoom","text":"<p>For preventing your content from over-zooming or over-panning, <code>Modifier.zoomable()</code> will use your content's layout size by default. This is good enough for composables that fill every pixel of their drawing space.</p> <p>For richer content such as an <code>Image()</code> whose visual size may not always match its layout size, <code>Modifier.zoomable()</code> will need your assistance.</p> <pre><code>val state = rememberZoomableState()\nval painter = resourcePainter(R.drawable.example)\nLaunchedEffect(painter) {\nstate.setContentLocation(\nZoomableContentLocation.scaledInsideAndCenterAligned(painter.intrinsicSize)\n)\n}\nImage(\nmodifier = Modifier\n.fillMaxSize()\n.zoomable(state),\npainter = painter,\ncontentDescription = \u2026,\ncontentScale = ContentScale.Inside,\nalignment = Alignment.Center,\n)\n</code></pre>"},{"location":"zoomable/#applying-gesture-transformations","title":"Applying gesture transformations","text":"<p>When pan &amp; zoom gestures are received, <code>Modifier.zoomable()</code> automatically applies their resulting <code>scale</code> and <code>translation</code> onto your content using <code>Modifier.graphicsLayer()</code>. </p> <p>This can be disabled if your content prefers applying the transformations in a bespoke manner.</p> <pre><code>val state = rememberZoomableState(\nautoApplyTransformations = false\n)\nText(\nmodifier = Modifier\n.fillMaxSize()\n.zoomable(state),\ntext = \"Nicolas Cage\",\nstyle = state.contentTransformation.let {\nval weightMultiplier = if (it.isUnspecified) 1f else it.scale.scaleX\nTextStyle(\nfontSize = 36.sp,\nfontWeight = FontWeight(400 * weightMultiplier),\n)\n}\n)\n</code></pre>"},{"location":"zoomable/recipes/","title":"Recipes","text":""},{"location":"zoomable/recipes/#reacting-to-zoom","title":"Reacting to zoom","text":"<pre><code>// Hide status and navigation bars when an image is zoomed in.\nval systemUiController = rememberSystemUiController()\nsystemUiController.isSystemBarsVisible = zoomableState.zoomFraction == 0f\n</code></pre>"},{"location":"zoomable/recipes/#resetting-pan-zoom","title":"Resetting pan &amp; zoom","text":"<p><code>Modifier.zoomable()</code> will automatically retain its pan &amp; zoom across state restorations. This isn't always desired with lazy layouts such as a <code>Pager()</code> where each page is restored every time it becomes visible. </p> <pre><code>val pagerState = rememberPagerState()\nval zoomableState = rememberZoomableState()\nHorizontalPager(\nstate = pagerState,\npageCount = 3,\n) { pageNum -&gt;\nBox(\nModifier.zoomable(zoomableState)\n)\nif (pagerState.settledPage != pageNum) {\n// Page is now off-screen. Prevent restoration \n// of zoom when this page becomes visible again.\nLaunchedEffect(Unit) {\nzoomableState.resetZoomImmediately()\n}\n}\n}\n</code></pre>"},{"location":"zoomableimage/","title":"Zoomable Image","text":"<p>A drop-in replacement for async <code>Image()</code> composables with support for pan &amp; zoom gestures. For images that are large enough to not fit in memory, sub\u2011sampling is automatically enabled so that they're displayed without any loss of detail when fully zoomed in.</p> CoilGlide <pre><code>implementation(\"me.saket.telephoto:zoomable-image-coil:1.0.0-SNAPSHOT\")\n</code></pre> <pre><code>implementation(\"me.saket.telephoto:zoomable-image-glide:1.0.0-SNAPSHOT\")\n</code></pre> CoilGlide <pre><code>- AsyncImage(\n+ ZoomableAsyncImage(\n   model = \"https://example.com/image.jpg\",\n    contentDescription = \u2026\n  )\n</code></pre> <pre><code>- GlideImage(\n+ ZoomableGlideImage(\n   model = \"https://example.com/image.jpg\",\n    contentDescription = \u2026\n  )\n</code></pre>"},{"location":"zoomableimage/#image-options","title":"Image options","text":"<p>For complex scenarios, the <code>model</code> parameter can also be given full image requests. </p> CoilGlide <pre><code>val imageLoader = LocalContext.current.imageLoader\n.newBuilder()\n.components { add(GifDecoder.Factory()) }\n.build()\nZoomableAsyncImage(\nmodel = ImageRequest.Builder(LocalContext.current)\n.data(\"https://example.com/image.jpg\")\n.listener(\nonStart = { \u2026 },\nonError = { \u2026 },\n)\n.crossfade(1_000)\n.memoryCachePolicy(CachePolicy.DISABLED)\n.allowHardware(true)\n.build(),\nimageLoader = imageLoader,\ncontentDescription = \u2026\n)\n</code></pre> <pre><code>ZoomableGlideImage(\nmodel = Glide\n.with(LocalContext.current)\n.load(\"https://example.com/image.jpg\")\n.addListener(object : RequestListener&lt;Drawable&gt; {\noverride fun onLoadFailed(\u2026): Boolean = TODO()\noverride fun onResourceReady(\u2026): Boolean = TODO()\n}),\n.transition(withCrossFade(1_000))\n.skipMemoryCache(true)\n.timeout(30_000)\n.addListener(\u2026),\ncontentDescription = \u2026\n)\n</code></pre>"},{"location":"zoomableimage/#placeholders","title":"Placeholders","text":"<p>If an image is available in multiple resolutions, it is highly recommended to use a lower resolution as a placeholder while its full quality equivalent is loaded in the background. When combined with a cross-fade transition, <code>ZoomableImage</code> will smoothly swap out the placeholder when the full quality version is ready to be displayed.</p> CoilGlide <p><pre><code>ZoomableAsyncImage(\nmodifier = Modifier.fillMaxSize(),\nmodel = ImageRequest.Builder(LocalContext.current)\n.data(\"https://example.com/image.jpg\")\n.placeholderMemoryCacheKey(\u2026)\n.crossfade(1000)\n.build(),\ncontentDescription = \u2026\n)\n</code></pre> More details about <code>placeholderMemoryCacheKey()</code> can be found on Coil's website.</p> <p><pre><code>ZoomableGlideImage(\nmodifier = Modifier.fillMaxSize(),\nmodel = Glide\n.with(LocalContext.current)\n.load(\"https://example.com/image.jpg\")\n.thumbnail(\u2026)   // or placeholder()\n.transition(withCrossFade(1000)),\ncontentDescription = \u2026\n)\n</code></pre> More details about <code>thumbnail()</code> can be found on Glide's website.</p>"},{"location":"zoomableimage/#click-listeners","title":"Click listeners","text":"<p>For detecting double taps, <code>Modifier.zoomable()</code> is sadly forced to consume all tap gestures making it incompatible with <code>Modifier.clickable()</code> and <code>Modifier.combinedClickable()</code>. As an alternative, its <code>onClick</code> and <code>onLongClick</code> parameters can be used.</p> CoilGlide <pre><code>ZoomableAsyncImage(\nmodifier = Modifier.clickable { error(\"This will not work\") },\nmodel = \"https://example.com/image.jpg\",\nonClick = { \u2026 },\nonLongClick = { \u2026 },\n)\n</code></pre> <pre><code>ZoomableGlideImage(\nmodifier = Modifier.clickable { error(\"This will not work\") },\nmodel = \"https://example.com/image.jpg\",\nonClick = { \u2026 },\nonLongClick = { \u2026 },\n)\n</code></pre>"},{"location":"zoomableimage/#hoisting-state","title":"Hoisting state","text":"<p>For handling zoom gestures, <code>Zoomablemage</code> uses <code>Modifier.zoomable()</code> underneath. If your app displays different kinds of media, it is recommended to hoist the <code>ZoomableState</code> outside so that it can be shared with all zoomable composables:</p> CoilGlide <pre><code>val zoomableState = rememberZoomableState()\nwhen (media) {\nis Image -&gt; {\nZoomableAsyncImage(\nmodel = media.imageUrl,\nstate = rememberZoomableImageState(zoomableState),\n)\n}\nis Video -&gt; {\nZoomableExoPlayer(\nmodel = media.videoUrl,\nstate = rememberZoomableExoState(zoomableState),\n)\n}\n}\n</code></pre> <pre><code>val zoomableState = rememberZoomableState()\nwhen (media) {\nis Image -&gt; {\nZoomableGlideImage(\nmodel = media.imageUrl,\nstate = rememberZoomableImageState(zoomableState),\n)\n}\nis Video -&gt; {\nZoomableExoPlayer(\nmodel = media.videoUrl,\nstate = rememberZoomableExoState(zoomableState),\n)\n}\n}\n</code></pre>"},{"location":"zoomableimage/content-alignment/","title":"Content alignment","text":"<p>Work in progress.</p>"},{"location":"zoomableimage/custom-image-loaders/","title":"Custom image loaders","text":"<p>In its essence, <code>ZoomableImage</code> is simply an abstraction over an image loading library. If your preferred library isn't supported by <code>telephoto</code> out of the box, you can create your own by extending <code>ZoomableImageSource</code>.</p> <pre><code>@Composable\nfun ZoomablePicassoImage(\nmodel: Any?,\ncontentDescription: String?,\n) {\nZoomableImage(\nimage = ZoomableImageSource.picasso(model),\ncontentDescription = contentDescription,\n)\n}\n@Composable\nprivate fun ZoomableImageSource.Companion.picasso(\nmodel: Any?,\npicasso: Picasso = Picasso.Builder(LocalContext.current).build(),\n): ZoomableImageSource {\nreturn remember(model, picasso) {\nTODO(\"See ZoomableImageSource.coil() or glide() for an example.\")\n}\n}\n</code></pre> <p><code>ZoomableImageSource.picasso()</code> will be responsible for loading an image and deciding whether it can be shown as-is or should be shown in a sub-sampling image viewer to avoid OOMs. Here are two examples:</p> <ul> <li>CoilImageSource</li> <li>GlideImageSource</li> </ul>"},{"location":"zoomableimage/recipes/","title":"Recipes","text":"<ul> <li>Reacting to zoom</li> <li>Resetting pan &amp; zoom</li> </ul>"},{"location":"zoomableimage/sub-sampling/","title":"Sub-sampling","text":"<p>For images that are large enough to not fit in memory, <code>ZoomableImage</code> automatically divides them into tiles so that they can be lazy loaded. </p> <p>If <code>ZoomableImage</code> can't be used or if sub-sampling of images is always desired, you could potentially use <code>SubSamplingImage()</code> directly:</p> <pre><code>implementation(\"me.saket.telephoto:sub-sampling-image:1.0.0-SNAPSHOT\")\n</code></pre> <pre><code>val zoomableState = rememberZoomableState()\nval imageState = rememberSubSamplingImageState(\nzoomableState = zoomableState,\nimageSource = ImageSource.asset(\"fox.jpg\")\n)\nSubSamplingImage(\nmodifier = Modifier\n.fillMaxSize()\n.zoomable(zoomableState),\nstate = imageState,\ncontentDescription = null,\n)\n</code></pre> <p><code>SubSamplingImage()</code> is a Compose implementation of the excellent subsampling-scale-image-view by Dave Morrissey.</p>"}]}